# encoding: utf-8

# abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?

###############################################################################################################################################################
###############################################################################################################################################################


require 'wavefile'
require 'coreaudio'

module CWG

  class Read

    TONE_400_BIN_NARROW =  0
    TONE_400_BIN_WIDE =  1
    TONE_450_BIN_NARROW =  2
    TONE_450_BIN_WIDE =  3
    TONE_500_BIN_NARROW =  4
    TONE_500_BIN_WIDE =  5
    TONE_550_BIN_NARROW =  6
    TONE_550_BIN_WIDE =  7
    TONE_600_BIN_NARROW =  8
    TONE_600_BIN_WIDE =  9
    TONE_700_BIN_NARROW =  10
    TONE_700_BIN_WIDE =  11
    TONE_800_BIN_NARROW =  12
    TONE_800_BIN_WIDE =  13
    TONE_900_BIN_NARROW =  14
    TONE_900_BIN_WIDE =  15
    TONE_1000_BIN_NARROW =  16
    TONE_1000_BIN_WIDE =  17
    TONE_500_BIN_V_NARROW =  18

    SOUND_CARD_RATE = 44100
    SAMPLING_DIVISOR = 1
    TONE_WIDTH    = 12
    SAMPLING_FREQ = SOUND_CARD_RATE / SAMPLING_DIVISOR
    DATA = [
      {tone: 400, bin_width: 40},
      {tone: 400, bin_width: 80},
      {tone: 450, bin_width: 45},
      {tone: 450, bin_width: 90},
      {tone: 500, bin_width: 50},
      {tone: 500, bin_width: 100},
      {tone: 550, bin_width: 55},
      {tone: 550, bin_width: 110},
      {tone: 600, bin_width: 60},
      {tone: 600, bin_width: 120},
      {tone: 700, bin_width: 70},
      {tone: 700, bin_width: 140},
      {tone: 800, bin_width: 80},
      {tone: 800, bin_width: 160},
      {tone: 900, bin_width: 90},
      {tone: 900, bin_width: 180},
      {tone: 1000, bin_width: 100},
      {tone: 1000, bin_width: 200},
      {tone: 500, bin_width: 25},
    ]
    def n ; @sample_rate / @bin_width ; end
    def k ; (0.5 + ((n * @tone) / @sample_rate)).to_i ; end
    def w ; ((2 * Math::PI) / n) * k ; end
    def cosine ; Math.cos(w) ; end
    def coeff ; 2 * cosine ; end
    def millis ; @millisecs; end
    def n_delay_ms ; ((1.0/SOUND_CARD_RATE) * n * 1000); end

    def initialize(filename)
      @out_file = File.new("timing.txt",'w+')
#      @out_file.close
      @mag_max = 0
      @mag_min = 999999999
      @sample_rate = SAMPLING_FREQ
      @tone_config = TONE_500_BIN_WIDE
      @tone = DATA[@tone_config][:tone]
      @bin_width = DATA[@tone_config][:bin_width] * SAMPLING_DIVISOR
      @n_val = n
      @coeff = coeff
      @n_delay_ms = n_delay_ms
      @filename = filename
      @code = []
      @cw_encoding = CwEncoding.new
      @q1 = 0
      @q2 = 0
      #      @magnitudelimit = 500000
      @magnitudelimit = 1000
      @magnitudelimit_low = @magnitudelimit
      @wpm = 25
      @real_state = false
      @filtered_state = false
      @real_state_store = false
      @filtered_state_store = false
      @start_time = 0.0
      @noise_blanking_period = 0
      @start_time_high = 0
      @high_period = 0
      @high_period_store = 0
      @high_time_period = 0
      @start_time_low = 0
      @low_period = 0
      @last_start_time = 0
      @millisecs = 0
      @last = 0

      puts "@n_val  #{@n_val}"
      input()
    end

    def input
      soundflower = nil
      CoreAudio.devices.each do |device|
        if device.name == 'Soundflower (2ch)'
          soundflower = device
        end
      end

      @buf_in = soundflower.input_buffer(44100)

      #      soundflower = CoreAudio.default_input_device
      #      puts "device: #{soundflower}"
      #      $stdout.print "Listening...\n"
      #      $stdout.flush

      thr_in = Thread.fork do
        loop do
          @buf_in.start
          loop do
            process_frame
            @millisecs += @n_delay_ms
            #          dbg_print "  @n_val: #{@n_val}\n  " +
            #                    "@sample_rate: #{@sample_rate}\n  " +
            #                    "@millisecs: #{@millisecs}\n  @n_delay_ms: #{@n_delay_ms}"
            per_block_processing
            magnitude_filter
            calc_real_state
            calc_filtered_state
            decode_signal
            store_high_period
            store_filtered_state
          end
        end
      end
      thr_in.join
      thr_in.kill.join
#      @buf_out.stop
#      puts "#{@buf_out.dropped_frame} frame dropped."
      @buf_in.stop
      $stdout.puts "done."
    end

    def magnitude_test
      soundflower = nil
      CoreAudio.devices.each do |device|
        if device.name == 'Soundflower (2ch)'
          soundflower = device
        end
      end

      @buf_in = soundflower.input_buffer(44100)

      #      soundflower = CoreAudio.default_input_device
      #      puts "device: #{soundflower}"
      #      $stdout.print "Listening...\n"
      #      $stdout.flush
      #      @dev_out = CoreAudio.default_output_device
      #      @buf = @dev_out.output_buffer(1024)

      thr_in = Thread.fork do
        @buf_in.start
        loop do
          process_frame
          @millisecs += @n_delay_ms
          #          dbg_print "  @n_val: #{@n_val}\n  " +
          #                    "@sample_rate: #{@sample_rate}\n  " +
          #                    "@millisecs: #{@millisecs}\n  @n_delay_ms: #{@n_delay_ms}"
          per_block_processing
          magnitude_filter
          calc_real_state
          calc_filtered_state
          decode_signal
          store_high_period
          store_filtered_state
        end
      end

      @dev_out = CoreAudio.default_output_device
      @buf_out = @dev_out.output_buffer(1024)
      @out_file = File.new("high_res_v_narrow.txt",'w+')
      (0..1000).step(2) do |x|
        puts "Freq: #{x}"
        thr_out = Thread.fork do
          generate_sinewave x.to_f
          thr_out.kill
        end
        thr_out.join
      end
      @out_file.close
      thr_in.kill.join
      @buf_out.stop
      puts "#{@buf_out.dropped_frame} frame dropped."
      @buf_in.stop
      $stdout.puts "done."
    end

    def generate_sinewave freq

      @phase = Math::PI * 2.0 * freq / @dev_out.nominal_rate
      int_freq = freq.to_i
      i = 0
      @wav = NArray.sint(int_freq)
      @buf_out.start
      (int_freq/4).times do
        (int_freq).times {|j| @wav[j] = (0.4 * Math.sin(@phase*(i+j)) * 0x7FFF).round }
        i += (int_freq)
        @buf_out << @wav
      end
      puts "  Max: #{(@mag_max / 1000000.0).round(3)}"
      @out_file.print "#{(@mag_max / 1000000.0).round(3)},"
      @mag_max = 0
    end

    def dbg_print message
      if @millisecs > @last
        @last = @millisecs + 1000
        puts
        puts "  " + message
        @mag_min = 999999999
        @mag_max = 0
      end
    end

    def process_frame
      bufs = @buf_in.read(@n_val)
      count = @n_val / SAMPLING_DIVISOR
      idx_multiplier = 2 * SAMPLING_DIVISOR
      count.times do |idx|
        update_coeffs_per_sample bufs[(idx * idx_multiplier)]
        #      bufs[0 ,0..-1].each do |x|
        #        update_coeffs_per_sample x
      end
    end

    def per_block_processing
      magnitude_squared = (@q1 * @q1) + (@q2 * @q2) - (@q1 * @q2 * @coeff)
      @magnitude = magnitude_squared.to_i
      @magnitude = Math.sqrt(magnitude_squared).to_i;
      @q1, @q2 = 0, 0;
      #      p @magnitude
    end

    def magnitude_filter
      if(@magnitude > @magnitudelimit_low)
        @magnitudelimit = (@magnitudelimit + ((@magnitude - @magnitudelimit) / 6))  # moving average filter
      else
        @magnitudelimit = @magnitudelimit_low
      end
      #      dbg_print "@magnitude: #{@magnitude.to_s}\n  @magnitudelimit: #{@magnitudelimit.to_s}\n  @magnitudelimit_low = #{@magnitudelimit_low}"

      @mag_max = @magnitude if @magnitude > @mag_max
      @mag_min = @magnitude if @magnitude < @mag_min

#      dbg_print "@magnitude: #{@magnitude.to_s}\n" +
#                "  @mag_max: #{@mag_max.to_s}\n" +
#                "  @mag_min: #{@mag_min.to_s}\n"
    end

    def calc_real_state
      @real_state =
        (@magnitude > (@magnitudelimit * 0.6)) ?
          true : false
    end

    def calc_filtered_state
      if real_state_change?
        reset_last_start_time
      end

      if((millis() - @last_start_time) > @noise_blanking_period)
        @filtered_state = @real_state
      end

      if filtered_state_change?
        if(@filtered_state == true)
          @start_time_high = millis()
          @low_period = (millis() - @start_time_low)
        else
          @start_time_low = millis();
          @high_period = (millis() - @start_time_high);
          if((@high_period < (2 * @high_time_period)) || (@high_time_period == 0))
            @high_time_period = (@high_period + @high_time_period + @high_time_period) / 3  # now we know avg dit time ( rolling 3 avg)
          end

          if(@high_period > (5 * @high_time_period))
            @high_time_period = @high_period + @high_time_period;     # if speed decrease fast ..
          end
        end
      end
      store_real_state
    end

    def decode_signal
      if(filtered_state_change?)
        if(@filtered_state == false) #  we did end a HIGH
          if matched_timings?(@high_period, @high_time_period, 2.0, 0.6)
            #  0.6 filter out false dits
            @code << :dot
            @out_file.print "#{@high_time_period},"
          end
          if matched_timings?(@high_period, @high_time_period, 6.0, 2.0)
            @code << :dash
          end
        else # we did end a LOW
          if matched_timings?(@low_period, @high_time_period, 5.0, 2.0) # letter space
            print_char
            @code.clear
          end
          if(@low_period >= (@high_time_period * 5.0)) # word space
            print_char
            @code.clear
            print ' '
          end
        end
      end
    end

    def update_coeffs_per_sample(data)
      q0 = @coeff * @q1 - @q2 + data
      #      dbg_print "  @k: #{@k}\n  @cosine: #{@cosine}\n  @coeff: #{@coeff}\n  q0: #{q0}\n"
      @q2, @q1 = @q1, q0
    end

    def reset_last_start_time
      @last_start_time = millis()
    end

    def real_state_change?
      #      if @real_state != @real_state_store
      #        print 'hi' if @real_state == true
      #        print 'low' if @real_state == false
      #      end
      @real_state != @real_state_store
    end

    def filtered_state_change?
      #      if @filtered_state != @filtered_state_store
      #        print 'hi' if @filtered_state == true
      #        print 'low' if @filtered_state == false
      #      end
      @filtered_state != @filtered_state_store
    end

    def matched_timings?(period, avg, avg_x_high, avg_x_low)
      ((period < (avg * avg_x_high)) &&
       (period > (avg * avg_x_low)))
    end

    def store_high_period
      @high_period_store = @high_period
    end

    def store_real_state
      @real_state_store = @real_state
    end

    def store_filtered_state
      @filtered_state_store = @filtered_state
    end

    def matched_char
      @cw_encoding.fetch_char @code
    end

    def print_char
#            puts @code
      print matched_char
    end

    def sample
      loop_count = 0
      @testData = Array.new(@n_val)
      WaveFile::Reader.new(@filename).each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
        #        p buffer
        #        exit
        loop do
          done = false
          count = 0
          @n_val.times do
            length = buffer.samples.length
            done = true unless(length > 0)
            #@millisecs += 0.43405
            @millisecs += 1
            @testData[count] = (buffer.samples.shift) unless done # + 32768
            @testData[count] = 0 if done
            #      print @testData[count]
            #      print ','
            update_coeffs_per_sample(count)
            count += 1
          end
          per_block_processing
          magnitude_filter
          calc_real_state
          calc_filtered_state
          decode_signal
          store_high_period
          store_filtered_state
          break if done
        end
        #        break if loop_count > 10000
        loop_count += 1
      end
      print_char
      puts
    end
  end
end
