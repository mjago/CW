# encoding: utf-8

# abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?  abc def ghi jkl mno pqr stu vwx yz1 234 567 890 .=?

###############################################################################################################################################################
###############################################################################################################################################################


require 'wavefile'
require 'coreaudio'

module CWG

  class Read
    SOUND_CARD_RATE = 44100
    SAMPLING_DIVISOR = 3
    TONE_WIDTH    = 12
    SAMPLING_FREQ = SOUND_CARD_RATE / SAMPLING_DIVISOR
    DATA = [
      {tone: 400, bin_width: 40},
      {tone: 400, bin_width: 80},
      {tone: 450, bin_width: 45},
      {tone: 450, bin_width: 90},
      {tone: 500, bin_width: 50},
      {tone: 500, bin_width: 100},
      {tone: 550, bin_width: 55},
      {tone: 550, bin_width: 110},
      {tone: 600, bin_width: 60},
      {tone: 600, bin_width: 120},
      {tone: 700, bin_width: 70},
      {tone: 700, bin_width: 140},
      {tone: 800, bin_width: 80},
      {tone: 800, bin_width: 160},
      {tone: 900, bin_width: 90},
      {tone: 900, bin_width: 180},
      {tone: 1000, bin_width: 50},
      {tone: 1000, bin_width: 100},
]
    def n ; @sample_rate/ @bin_width ; end
    def k ; (0.5 + ((n * @tone) / @sample_rate)).to_i ; end
    def w ; ((2 * Math::PI) / n) * k ; end
    def cosine ; Math.cos(w) ; end
    def coeff ; 2 * cosine ; end
    def millis ; @millisecs; end
    def n_delay_ms ; ((1.0/@sample_rate) * @n_val * 1000); end

    def initialize(filename)
      @sample_rate = SAMPLING_FREQ
      @tone = DATA[TONE_WIDTH][:tone]
      @bin_width = DATA[TONE_WIDTH][:bin_width]
      @n_val = n
      @coeff = coeff
      @n_delay_ms = n_delay_ms
      @filename = filename
      @code = []
      @cw_encoding = CwEncoding.new
      @q1 = 0
      @q2 = 0
#      @magnitudelimit = 500000
      @magnitudelimit_low = 50000
      @magnitudelimit = 20000
      @magnitudelimit_low = @magnitudelimit
      @wpm = 25
      @real_state = false
      @filtered_state = false
      @real_state_store = false
      @filtered_state_store = false
      @start_time = Time.now
      @noise_blanking_period = 50
      @start_time_high = 0
      @high_period = 0
      @high_period_store = 0
      @high_times_avg = 0
      @start_time_low = 0
      @low_period = 0
      @last_start_time = 0
      @millisecs = 0.0
      @last = Time.now.to_i

      puts "@n_val  #{@n_val}"
      input()
    end

    def dbg_print message
      @latest = Time.now.to_i
      if @latest > @last + 2
        @last = @latest
        puts
        puts "  " + message
      end
    end

    def process_frame buffer
      bufs = buffer.read(@n_val)
      count = @n_val / SAMPLING_DIVISOR
      idx_multiplier = 2 * SAMPLING_DIVISOR
      count.times do |idx|
        update_coeffs_per_sample bufs[(idx * idx_multiplier)]
        #      bufs[0 ,0..-1].each do |x|
        #        update_coeffs_per_sample x
      end
    end

    def input
      soundflower = nil
      CoreAudio.devices.each do |device|
        if device.name == 'Soundflower (2ch)'
          soundflower = device
        end
      end
#      soundflower = CoreAudio.default_input_device
      puts "device: #{soundflower}"
      buffer = soundflower.input_buffer(44100)
      $stdout.print "Listening...\n"
      $stdout.flush
      buffer.start
      loop do
        process_frame buffer
        @millisecs += @n_delay_ms
        per_block_processing
        magnitude_filter
        calc_real_state
        calc_filtered_state
        decode_signal
      end
    end

    def sample
      loop_count = 0
      @testData = Array.new(@n_val)
      count_N = 0
      WaveFile::Reader.new(@filename).each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
#        p buffer
#        exit
        loop do
          done = false
          count = 0
          @n_val.times do
            length = buffer.samples.length
            done = true unless(length > 0)
            #@millisecs += 0.43405
            @millisecs += 1
            @testData[count] = (buffer.samples.shift) unless done # + 32768
            @testData[count] = 0 if done
            #      print @testData[count]
            #      print ','
            update_coeffs_per_sample(count)
            count += 1
          end
          per_block_processing
          magnitude_filter
          calc_real_state
          calc_filtered_state
          decode_signal
          break if done
        end
#        break if loop_count > 10000
        loop_count += 1
      end
      print_char
      puts
    end

    def update_coeffs_per_sample(data)
      q0 = @coeff * @q1 - @q2 + data
#      dbg_print "  @k: #{@k}\n  @cosine: #{@cosine}\n  @coeff: #{@coeff}\n  q0: #{q0}\n"
      @q2, @q1 = @q1, q0
    end

    def per_block_processing
      magnitude_squared = (@q1 * @q1) + (@q2 * @q2) - (@q1 * @q2 * @coeff)
      @magnitude = magnitude_squared.to_i
#      @magnitude = Math.sqrt(magnitude_squared).to_i;
      @q1, @q2 = 0, 0;
#      p @magnitude
    end

    def magnitude_filter
      if(@magnitude > @magnitudelimit_low)
        @magnitudelimit = (@magnitudelimit + ((@magnitude - @magnitudelimit) / 6))  # moving average filter
      else
        @magnitudelimit = @magnitudelimit_low
      end
#      dbg_print "@magnitude: #{@magnitude.to_s}\n  @magnitudelimit: #{@magnitudelimit.to_s}\n  @magnitudelimit_low = #{@magnitudelimit_low}"
#      dbg_print "@magnitude: #{@magnitude.to_s}"
    end

    def calc_real_state
      @real_state =
        (@magnitude > (@magnitudelimit * 0.6)) ?
          true : false
    end

    def reset_last_start_time
      @last_start_time = millis()
    end

    def real_state_change?
      @real_state != @real_state_store
    end

    def filtered_state_change?
#      if @filtered_state != @filtered_state_store
#        print 'hi' if @filtered_state == true
#        print 'low' if @filtered_state == false
#      end
      @filtered_state != @filtered_state_store
    end

    def calc_filtered_state
      if real_state_change?
        reset_last_start_time
      end

      if((millis() - @last_start_time) > @noise_blanking_period)
        @filtered_state = @real_state
      end

      if filtered_state_change?
        if(@filtered_state == true)
          @start_time_high = millis()
          @low_period = (millis() - @start_time_low)
        else
          @start_time_low = millis();
          @high_period = (millis() - @start_time_high);
          if((@high_period < (2 * @high_times_avg)) || (@high_times_avg == 0))
            @high_times_avg = (@high_period + @high_times_avg + @high_times_avg) / 3  # now we know avg dit time ( rolling 3 avg)
          end

          if(@high_period > (5 * @high_times_avg))
            @high_times_avg = @high_period + @high_times_avg;     # if speed decrease fast ..
          end
        end
      end
      store_real_state
    end

    def matched_timings?(period, avg, avg_x_high, avg_x_low)
      ((period < (avg * avg_x_high)) &&
       (period > (avg * avg_x_low)))
    end
    def decode_signal
      if(filtered_state_change?)
        if(@filtered_state == false) #  we did end a HIGH
          if matched_timings?(@high_period, @high_times_avg, 2.0, 0.6)
            #  0.6 filter out false dits
            @code << :dot
          end
          if matched_timings?(@high_period, @high_times_avg, 6.0, 2.0)
            @code << :dash
          end
        else # we did end a LOW
          if matched_timings?(@low_period, @high_times_avg, 5.0, 2.0) # letter space
            print_char
            @code.clear
          end
          if(@low_period >= (@high_times_avg * 5.0)) # word space
            print_char
            @code.clear
            print ' '
          end
        end
      end

      store_high_period
      store_filtered_state

    end

    def store_high_period
      @high_period_store = @high_period
    end

    def store_real_state
      @real_state_store = @real_state
    end

    def store_filtered_state
      @filtered_state_store = @filtered_state
    end

    def matched_char
      @cw_encoding.fetch_char @code
    end

    def print_char
#      puts @code
      print matched_char
    end
  end
end
